# Execution Order / Pipeline (MVP)

## 1) Цель блока

Зафиксировать единый порядок обработки времени, планировщика, команд, тика карты и обработки событий.

Карта остаётся единственным источником истины о пространстве, но внешний слой определяет, когда применяются внешние команды.

---

## 2) Участники пайплайна

- **SimulationLoop / TickSource** — источник тиков
- **Scheduler** — выдаёт отложенные SimulationCommand[]
- **External Systems** — применяют команды и обрабатывают MapEvent[]
- **Map** — исполняет пространственные процессы и возвращает MapTickResult

---

## 3) Порядок одного тика

Для каждого тика T выполняется **строго**:

### Шаг 0 — Increment Time

- SimulationTime.tick = T

### Шаг 1 — Scheduler Due Commands

- SchedulerTickResult = Scheduler.PopDue(T)
- получаем SchedulerTickResult.commands: SimulationCommand[]

### Шаг 2 — Apply Commands (внешний слой)

Внешний слой применяет команды **до** вызова Map.Tick(T).

**MapCommand:** RegisterEntity, DeregisterEntity, EnterPOI, ExitPOI, SetEntityStatus, SetEntityPosition

**ControllerCommand:** PushIntent, CancelIntent

*Результат шага 2: к моменту вызова Map.Tick(T): состав entitiesById актуален, статусы и позиции актуальны, активные движения/маршруты/цели актуальны.*

### Шаг 3 — Map Tick (пространственная логика)

- MapTickResult = Map.Tick(T)

Карта делает:
- движение по ребру (∆progress)
- переходы ребро↔узел по правилам
- расчёт дистанций (когда нужно для правил)
- обнаружение (по правилам)
- встречи (узел или общее ребро+progress)
- фиксацию событий в MapEvent[]
- остановку движения и перевод в устойчивые статусы (если требуется контрактом)

### Шаг 4 — Emit Map Events (наружу)

- Внешний слой получает MapTickResult.events: MapEvent[]

Внешний слой обрабатывает события:
- запускает внешние процессы (бой и т.п.)
- планирует новые ScheduledItem
- пушит новые намерения контролёров
- дерегистрирует сущности при входе в POI (если это оформлено как внешняя команда)
- выполняет любые "почему" и "что дальше" решения

---

## 4) Правила "атомарности" внутри тика

Чтобы избежать споров "в каком порядке что считается", фиксируем:

### 4.1 Команды применяются до тика карты

Все SimulationCommand с dueTick <= T применяются до Map.Tick(T).

### 4.2 Карта возвращает события "по факту тика"

Любое событие в events имеет tick = T.

### 4.3 События карты не применяют команды автоматически

MapEvent — это факт, а не команда.

Реакция на событие — всегда во внешнем слое (шаг 4).

---

## 5) POI и дерегистрация — порядок

Фиксируем, чтобы не было двусмысленности.

**Вариант MVP (рекомендуемый, консистентный с пайплайном):**

- Карта генерирует POIEvent(kind=EnteredPOI) в Map.Tick(T).
- Внешний слой на следующем тике (или в конце текущего шага 4) планирует/исполняет: MapCommand.DeregisterEntity(entityId, reason=EnterPOI, poiId=...)

*Консеквенция: "вошёл в POI" фиксируется на тике T, а "исчез с карты" гарантированно произойдёт не позднее начала тика T+1.*

Это сохраняет принцип: карта не делает внешних изменений сама, но при этом поведение остаётся детерминированным.

---

## 6) Encounter — порядок

- Encounter определяется в Map.Tick(T).
- Encounter порождает EncounterEvent.

Внешний слой по событию может:
- поставить обоих в Engaged
- дерегистрировать (если бой вне карты требует убрать сущностей)
- запланировать бой как WorldCommand.StartExternalProcess

Исход боя — вне карты.

---

## 7) Недостижимость целей/маршрутов

Если в Map.Tick(T) цель/маршрут становится недействительным:
- карта останавливает движение (в рамках своих правил)
- генерирует TargetEvent или RouteEvent

Дальнейшее решение — контролёр/внешняя система.

---

## 8) Инварианты (MVP, текстом)

- Scheduler.PopDue(T) вызывается ровно один раз на тик.
- Map.Tick(T) вызывается ровно один раз на тик.
- Команды всегда применяются до Map.Tick(T).
- События карты всегда обрабатываются после Map.Tick(T).
